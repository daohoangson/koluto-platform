var util = require('util');
var _ = require('underscore')._;

var Tokenizer = function(options) {
    var options = options || {};
    
    // exception:
    // - not included to support some odd type of words
    this._punctuationPattern = new RegExp(/[~`!@#$%\^&\*\(\)\-_=\+\[{\]}\\\|;:'",<.>\/\? …“” •–≤’®©]/);
    
    this._numberPattern = new RegExp(/^[0-9][0-9,\.%\-\/]*( (tỉ|tỷ|triệu|vạn|nghìn|ngàn|trăm|phần))*( (đồng|usd|năm|tháng|tuần|ngày)(\/[^ ]+)?)?$/);
    this._pureNumberPattern = new RegExp(/[0-9]+/);
    this._nonNumberPattern = new RegExp(/[^0-9]+/);
};

Tokenizer.prototype.normalize = function(text) {
    return text.toLowerCase().replace(/\s+/g, ' ').trim();
}

Tokenizer.prototype.tokenize = function(text) {
    var thisTokenize = this;
    var result = {
        'tokens': [],
        'special': []
    };

    // split the tokens ourself
    // previously, we used String.split() method
    // however, we are doing it manually here to
    // recognize more stuff
    var a_tmp = [];
    var pendingPunctuation = false;
    var addTmp = function(f_isEOF) {
        // copy the pending punctuation and reset it
        var localPendingPunctuation = pendingPunctuation;
        pendingPunctuation = false;
        
        if (a_tmp.length > 0) {
            var s_tmp2 = a_tmp.join('');
            var a_tmp2 = s_tmp2.split(' ');
            var f_foundSomething = false;
            var f_isNumber = false;
            var f_isName = false;
            
            //console.log('s_tmp2:', s_tmp2);
            
            if (!f_foundSomething) {
                if (thisTokenize.normalize(s_tmp2).match(thisTokenize._numberPattern)) {
                    f_isNumber = true;
                    f_foundSomething = true;

                    if (localPendingPunctuation == '%') {
                        // special case: percentage character right after a number
                        // append it now
                        s_tmp2 += localPendingPunctuation;
                        a_tmp2.push(localPendingPunctuation);
                        a_tmp.push(localPendingPunctuation);
                    }
                } else {
                    f_isNumber = false;
                }
            }
            
            if (!f_foundSomething) {
                f_isName = true;
                
                for (var i = 0, l = a_tmp2.length; i < l; i++) {
                    var s_tmp3 = a_tmp2[i];
                    
                    if (s_tmp3.length == 0) {
                        // bypass empty string
                        // this should only happen if the caller intentionally want to 
                        // trick this function to process remaining buffer...
                        continue;
                    }
                    
                    var c3 = s_tmp3[0];
                    if (c3.toLowerCase() == c3) {
                        // this is a lower case character!
                        f_isName = false;
                    }
                    
                    if (f_isName) {
                        // the first character is a capitalized one, good
                        // check for the rest
                        var uppercaseCount = 0;
                        for (var i2 = 1, l2 = s_tmp3.length; i2 < l2; i2++) {
                            c3 = s_tmp3[i2];
                            if (c3.toLowerCase() != c3) {
                                // this is an uppercase character!
                                f_isName = false;
                                uppercaseCount++;
                            }
                        }
                        
                        if (!f_isName) {
                            // it f_isName is false here
                            // that means more uppercase character has been found
                            // now have a special case: if all characters are uppercase?
                            // accept it then
                            if (uppercaseCount == s_tmp3.length - 1) {
                                f_isName = true;
                            }
                        }
                    } else {
                        // the first character is in lowercase, count uppercase characters
                        // and accept it as name if this word contains exactly one uppercase character
                        // something like iPhone, iPad, etc.
                        var uppercaseCount = 0;
                        for (var i2 = 1, l2 = s_tmp3.length; i2 < l2; i2++) {
                            c3 = s_tmp3[i2];
                            if (c3.toLowerCase() != c3) {
                                // this is an uppercase character!
                                uppercaseCount++;
                            }
                        }
                        
                        if (s_tmp3.length > 2 &&
                            (uppercaseCount == 1 || (i == 0 && uppercaseCount == s_tmp3.length - 1))) {
                            // okie, accept it as name
                            // special case: if the word is the first in a sentence
                            // the first character is forced to lowercase 
                            // however, we accept all uppercase words
                            // so with those all-uppercase-but-have-lowercase-first-character words
                            // just accept it
                            f_isName = true;
                        }
                    }
                    
                    if (!f_isName) break; // for (var i = 0, l = a_tmp2.length; i < l; i++)
                }
                
                if (f_isName) {
                    f_foundSomething = true;
                }
            }
            
            //console.log('isNumber:', f_isNumber, 'isName:', f_isName, 'foundSomething:', f_foundSomething, 'isEOF:', f_isEOF);
            
            if (f_isEOF) {
                // do extra work to remove space between numbers like '100 000' -> '100000'
                if (a_tmp2.length > 1) {
                    var i_numberCount = 0;
                    for (var i = 0, l = a_tmp2.length; i < l; i++) {
                        if (a_tmp2[i].match(thisTokenize._pureNumberPattern)) {
                            i_numberCount++;
                        } else {
                            // break immediately because we should only merge elements
                            // at the begining of a_tmp2
                            break;
                        }
                    }
                    if (i_numberCount > 0) {
                        var a_tmp3 = [];
                        for (var i = 0; i < i_numberCount; i++) {
                            a_tmp3.push(a_tmp2.shift());
                        }
                        a_tmp2.unshift(a_tmp3.join(''));
                    }
                }
                // finished merging numbers
                
                var s_tmp3 = thisTokenize.normalize(a_tmp2.join(' '));
                
                // do extra check to ignore token that mixes number and non-number
                // of course, bypass this check if this token is special in someway
                if (s_tmp3 && s_tmp3.length > 0 && !f_foundSomething) {
                    if (thisTokenize.isMixedNumberAndNonNumber(s_tmp3)) {
                        s_tmp3 = false;
                    }
                }
                
                // do extra check to bypass some generic numbers
                if (s_tmp3 && s_tmp3.length > 0 && f_isNumber) {
                    if (s_tmp3.match(/^[0-9]+$/) && parseInt(s_tmp3) < 100) {
                        s_tmp3 = false;
                    }
                }
                
                if (s_tmp3 && s_tmp3.length > 0) {
                    // everything looks good now, let's add it to the result
                    result.tokens.push(s_tmp3);
                    if (f_foundSomething) {
                        result.special.push(s_tmp3);
                    }
                }
                
                // reset tmp array
                a_tmp.length = 0;
            } else if (f_foundSomething) {
                // something potential
                // add space then continue
                a_tmp.push(' ');
            } else {
                var s_tmp4 = false;
                if (a_tmp2.length > 1) {
                    s_tmp4 = a_tmp2.pop();
                }
                var s_tmp3 = a_tmp2.join(' ');
                
                if (s_tmp3 && s_tmp3.length > 0) {
                    a_tmp.length = 0;
                    a_tmp = s_tmp3.split('');
                    addTmp(true);
                }
                
                // reset tmp array
                a_tmp.length = 0;
                
                if (s_tmp4 && s_tmp4.length > 0) {
                    // recursively call addTmp() again to handle the rest...
                    a_tmp = s_tmp4.split('');
                    addTmp();
                }
            }
        }
    };
    
    var f_isFirstInSentence = true;
    for (var i = 0, l = text.length; i < l; i++) {
        var c = text.substr(i, 1);
        if (thisTokenize._punctuationPattern.test(c)) {
            // this is a punctuation character
            
            // special case
            switch (c) {
            case '-':
            case '/':
                if ((i == 0 || !thisTokenize._punctuationPattern.test(text[i + 1]))
                    && (text.length <= i + 1 || !thisTokenize._punctuationPattern.test(text[i + 1])))
                {
                    // previous and next character is not a punctuation
                    // add this '-' into tmp and go to next character
                    a_tmp.push(c);
                    continue;
                }
            case ',':
                if (text.length > i + 1 && thisTokenize.hasNumber(text[i + 1])) {
                    // this is a ',' and the next is a number
                    // add this ',' into tmp and go straight to next character
                    a_tmp.push(c);
                    continue;
                }
                break;
            case '.':
                if (text.length > i + 1 && thisTokenize.hasNumber(text[i + 1])) {
                    // this is a '.' and the next is a number
                    // add this '.' into tmp and go straight to next character
                    a_tmp.push(c);
                    continue;
                } else {
                    // mark a new sentence is coming
                    // this may signal incorrectly in some cases
                    // we should check for space characters
                    // TODO: check for space characters
                    f_isFirstInSentence = true;
                }
                break;
            }
            
            // keep a copy of this punctuation
            pendingPunctuation = c;
            addTmp();
        } else {
            if (f_isFirstInSentence) {
                c = c.toLowerCase(); // ignore capital character at the beginning of sentence.
            }
            
            a_tmp.push(c);
            
            f_isFirstInSentence = false;
        }
    }
    
    // use a fake character to process the current queue
    a_tmp.push('');
    addTmp();
    
    // force adding any remaining bit in queue
    addTmp(true);

    return result;
};

Tokenizer.prototype.isMixedNumberAndNonNumber = function(text) {
    var hasNumber = this.hasNumber(text);
    var hasNonNumber = text.match(this._nonNumberPattern) != null;

    return (hasNumber && hasNonNumber);
}

Tokenizer.prototype.hasNumber = function(text) {
    return (text.match(this._pureNumberPattern) != null);
}

module.exports = Tokenizer;