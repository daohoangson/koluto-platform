var util = require('util');
var _ = require('underscore')._;

var Tokenizer = function(options) {
    var options = options || {};
    
    // exception:
    // - not included to support some odd type of words
    this._punctuationPattern = new RegExp(/[~`!@#$%\^&\*\(\)_=\+\[{\]}\\\|;:'",<.>\/\? …“” •–≤’®©]/);
    
    this._numberPattern = new RegExp(/^[0-9][0-9,\.% ]+( (tỉ|tỷ|triệu|vạn|nghìn|ngàn|trăm|phần))*( (đồng|năm|tháng|tuần|ngày))?$/);
    this._pureNumberPattern = new RegExp(/[0-9]+/);
    this._nonNumberPattern = new RegExp(/[^0-9]+/);
};

Tokenizer.prototype.normalize = function(text) {
    return text.toLowerCase().replace(/\s+/g, ' ').trim();
}

Tokenizer.prototype.tokenize = function(text) {
    var thisTokenize = this;
    var result = {
        'tokens': [],
        'special': []
    };

    // split the tokens ourself
    // previously, we used String.split() method
    // however, we are doing it manually here to
    // recognize more stuff
    var a_tmp = [];
    var pendingPunctuation = false;
    var addTmp = function(f_isEOF) {
        // copy the pending punctuation and reset it
        var localPendingPunctuation = pendingPunctuation;
        pendingPunctuation = false;
        
        if (a_tmp.length > 0) {
            var s_tmp2 = a_tmp.join('');
            var a_tmp2 = s_tmp2.split(' ');
            var f_foundSomething = false;
            var f_isNumber = true;
            var f_isName = true;
            
            // console.log('s_tmp2:', s_tmp2);
            
            if (!f_foundSomething) {
                if (thisTokenize.normalize(s_tmp2).match(thisTokenize._numberPattern)) {
                    f_isNumber = true;
                    f_foundSomething = true;

                    if (localPendingPunctuation == '%') {
                        // special case: percentage character right after a number
                        // append it now
                        s_tmp2 += localPendingPunctuation;
                        a_tmp2.push(localPendingPunctuation);
                        a_tmp.push(localPendingPunctuation);
                    }
                } else {
                    f_isNumber = false;
                }
            }
            
            if (!f_foundSomething) {
                for (var i = 0, l = a_tmp2.length; i < l; i++) {
                    var s_tmp3 = a_tmp2[i];
                    var c3 = s_tmp3.substr(0, 1);
                    if (c3.toLowerCase() == c3) {
                        // this is a lower case character!
                        f_isName = false;
                    }

                    for (var i2 = 1, l2 = s_tmp2.length; i2 < l2; i2++) {
                        c3 = s_tmp3.substr(i2, 1);
                        if (c3.toLowerCase() != c3) {
                            // this is an uppercase character!
                            f_isName = false;
                        }
                    }
                }
                
                if (f_isName) {
                    f_foundSomething = true;
                }
            }
            
            // console.log('isNumber:', f_isNumber, 'isName:', f_isName, 'foundSomething:', f_foundSomething, 'isEOF:', f_isEOF);
            
            if (f_isEOF) {
                // do extra work to remove space between numbers like '100 000' -> '100000'
                if (a_tmp2.length > 1) {
                    var i_numberCount = 0;
                    for (var i = 0, l = a_tmp2.length; i < l; i++) {
                        if (a_tmp2[i].match(thisTokenize._pureNumberPattern)) {
                            i_numberCount++;
                        } else {
                            // break immediately because we should only merge elements
                            // at the begining of a_tmp2
                            break;
                        }
                    }
                    if (i_numberCount > 0) {
                        var a_tmp3 = [];
                        for (var i = 0; i < i_numberCount; i++) {
                            a_tmp3.push(a_tmp2.shift());
                        }
                        a_tmp2.unshift(a_tmp3.join(''));
                    }
                }
                // finished merging numbers
                
                var s_tmp3 = thisTokenize.normalize(a_tmp2.join(' '));
                
                // do extra check to ignore token that mixes number and non-number
                // of course, bypass this check if this token is special in someway
                if (s_tmp3 && s_tmp3.length > 0 && !f_foundSomething) {
                    if (thisTokenize.isMixedNumberAndNonNumber(s_tmp3)) {
                        s_tmp3 = false;
                    }
                }
                
                if (s_tmp3 && s_tmp3.length > 0) {
                    // everything looks good now, let's add it to the result
                    result.tokens.push(s_tmp3);
                    if (f_foundSomething) {
                        result.special.push(s_tmp3);
                    }
                }
                
                // reset tmp array
                a_tmp.length = 0;
            } else if (f_foundSomething) {
                // something potential
                // add space then continue
                a_tmp.push(' ');
            } else {
                var s_tmp4 = false;
                if (a_tmp2.length > 1) {
                    s_tmp4 = a_tmp2.pop();
                }
                var s_tmp3 = a_tmp2.join(' ');
                
                if (s_tmp3 && s_tmp3.length > 0) {
                    a_tmp.length = 0;
                    a_tmp = s_tmp3.split('');
                    addTmp(true);
                }
                
                // reset tmp array
                a_tmp.length = 0;
                
                if (s_tmp4 && s_tmp4.length > 0) {
                    // recursively call addTmp() again to handle the rest...
                    a_tmp = s_tmp4.split('');
                    addTmp();
                }
            }
        }
    };
    
    var f_isFirstInSentence = true;
    for (var i = 0, l = text.length; i < l; i++) {
        var c = text.substr(i, 1);
        if (thisTokenize._punctuationPattern.test(c)) {
            // this is a punctuation character
            
            // special case
            switch (c) {
            case ',':
                if (thisTokenize.hasNumber(text.substr(i + 1, 1))) {
                    // this is a ',' and the next is a number
                    // add this ',' into tmp and go straight to next character
                    a_tmp.push(c);
                    continue;
                }
                break;
            case '.':
                if (thisTokenize.hasNumber(text.substr(i + 1, 1))) {
                    // this is a ',' and the next is a number
                    // add this ',' into tmp and go straight to next character
                    a_tmp.push(c);
                    continue;
                } else {
                    // mark a new sentence is coming
                    // this may signal incorrectly in some cases
                    // we should check for space characters
                    // TODO: check for space characters
                    f_isFirstInSentence = true;
                }
                break;
            }
            
            // keep a copy of this punctuation
            pendingPunctuation = c;
            addTmp();
        } else {
            if (f_isFirstInSentence) {
                c = c.toLowerCase(); // ignore capital character at the beginning of sentence.
            }
            
            a_tmp.push(c);
            
            f_isFirstInSentence = false;
        }
    }
    
    // use a fake character to process the current queue
    a_tmp.push('');
    addTmp();
    
    // force adding any remaining bit in queue
    addTmp(true);

    return result;
};

Tokenizer.prototype.isMixedNumberAndNonNumber = function(text) {
    var hasNumber = this.hasNumber(text);
    var hasNonNumber = text.match(this._nonNumberPattern) != null;

    return (hasNumber && hasNonNumber);
}

Tokenizer.prototype.hasNumber = function(text) {
    return (text.match(this._pureNumberPattern) != null);
}

module.exports = Tokenizer;